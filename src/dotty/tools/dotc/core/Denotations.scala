package dotty.tools.dotc
package core

import Periods._, Contexts._, Symbols._, References._, Names._
import Types._, Flags._, Decorators._
import Scopes.Scope
import collection.mutable

trait Denotations { self: Context =>


}

object Denotations {

  abstract class Denotation {

    /** The validity interval of this symbol */
    var valid: Interval = Nowhere

    /** The next instance of this symbol in the same run */
    private[core] var nextInRun: Denotation = this

    /**
     * The version of this symbol that was valid in the first phase
     *  of this run
     */
    def initial: Denotation = {
      var sym = nextInRun
      while (sym.valid > this.valid) sym = sym.nextInRun
      sym
    }

    def owner: Symbol = ???

    def name: Name = ???

    def flags: FlagSet = ???

    def setFlag(flag: FlagSet): Unit = ???

    def tpe: Type = ???

    def info: Type = ???

    /* Validity and instance handling:
     *
     * Symbols have an interval of validity, defined
     * by their `valid` fields.
     *
     * There may be several symbols with different validity
     * representing the same underlying symbol at different phases.
     * These are called a "flock". Flock members are generated by
     * @see SymRef.trackSym. Flock members are connected in a ring
     * with their `nextInFlock` fields.
     *
     * There are the following invariants converning flock members
     *
     * 1) validity intervals must be non-overlapping
     * 2) the union of all validity intervals must be a contiguous
     *    interval starting in FirstPhaseId.
     */

    /** is this symbol a type? */
    def isType: Boolean = false

    /** is this symbol a class? */
    def isClass: Boolean = false

    /** is this symbol a method? */
    def isMethod: Boolean = false

    /** is this symbol the result of an erroneous definition? */
    def isError: Boolean = false

    def withType(tp: Type): Denotation = ???
  }

  object NameFilter {
    final val WordSizeLog = 6
    final val DefinedNamesWords = 16
    final val DefinedNamesSize = DefinedNamesWords << WordSizeLog
    final val DefinedNamesMask = DefinedNamesSize - 1

    type FingerPrint = Array[Long]

    def includeName(bits: FingerPrint, name: Name): Unit = {
      val hash = name.start & DefinedNamesMask
      bits(hash >> 6) |= (1 << hash)
    }

    def includeFingerPrint(bits1: FingerPrint, bits2: FingerPrint): Unit =
      for (i <- 0 until DefinedNamesWords) bits1(i) |= bits2(i)

    def containsName(bits: FingerPrint, name: Name): Boolean = {
      val hash = name.start & DefinedNamesMask
      (bits(hash >> 6) & (1 << hash)) != 0
    }

    def newNameFilter: FingerPrint = new Array[Long](DefinedNamesWords)
  }

  object NoDenotation extends Denotation {
    override def owner: Symbol = throw new AssertionError("NoDenotation.owner")
    override def name: Name = BootNameTable.newTermName("<none>")
    override def flags = Flags.Empty
    override def tpe: Type = NoType
    override def info: Type = NoType
  }


}